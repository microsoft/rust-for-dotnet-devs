<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Memory Management - Rust for C#/.NET Developers</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../ferris.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../license.html">License</a></li><li class="chapter-item expanded affix "><a href="../contributing.html">Contributing</a></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/scalar-types.html"><strong aria-hidden="true">2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="../language/strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../language/structured-types.html"><strong aria-hidden="true">2.3.</strong> Structured Types</a></li><li class="chapter-item expanded "><a href="../language/custom-types/index.html"><strong aria-hidden="true">2.4.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/custom-types/classes.html"><strong aria-hidden="true">2.4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../language/custom-types/records.html"><strong aria-hidden="true">2.4.2.</strong> Records</a></li><li class="chapter-item expanded "><a href="../language/custom-types/structs.html"><strong aria-hidden="true">2.4.3.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../language/custom-types/interfaces.html"><strong aria-hidden="true">2.4.4.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="../language/custom-types/enums.html"><strong aria-hidden="true">2.4.5.</strong> Enumeration Types</a></li><li class="chapter-item expanded "><a href="../language/custom-types/members.html"><strong aria-hidden="true">2.4.6.</strong> Members</a></li></ol></li><li class="chapter-item expanded "><a href="../language/local-functions.html"><strong aria-hidden="true">2.5.</strong> Local Functions</a></li><li class="chapter-item expanded "><a href="../language/lambda-and-closures.html"><strong aria-hidden="true">2.6.</strong> Lambda and Closures</a></li><li class="chapter-item expanded "><a href="../language/variables.html"><strong aria-hidden="true">2.7.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../language/namespaces.html"><strong aria-hidden="true">2.8.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../language/equality.html"><strong aria-hidden="true">2.9.</strong> Equality</a></li><li class="chapter-item expanded "><a href="../language/generics.html"><strong aria-hidden="true">2.10.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../language/polymorphism.html"><strong aria-hidden="true">2.11.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../language/inheritance.html"><strong aria-hidden="true">2.12.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../language/exception-handling.html"><strong aria-hidden="true">2.13.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="../language/nullability-and-optionality.html"><strong aria-hidden="true">2.14.</strong> Nullability and Optionality</a></li><li class="chapter-item expanded "><a href="../language/discards.html"><strong aria-hidden="true">2.15.</strong> Discards</a></li><li class="chapter-item expanded "><a href="../language/conversion-and-casting.html"><strong aria-hidden="true">2.16.</strong> Conversion and Casting</a></li><li class="chapter-item expanded "><a href="../language/operator-overloading.html"><strong aria-hidden="true">2.17.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="../language/documentation-comments.html"><strong aria-hidden="true">2.18.</strong> Documentation Comments</a></li></ol></li><li class="chapter-item expanded "><a href="../memory-management/index.html" class="active"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../resource-management/index.html"><strong aria-hidden="true">4.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="../threading/index.html"><strong aria-hidden="true">5.</strong> Threading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threading/synchronization.html"><strong aria-hidden="true">5.1.</strong> Synchronization</a></li><li class="chapter-item expanded "><a href="../threading/producer-consumer.html"><strong aria-hidden="true">5.2.</strong> Producer-Consumer</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/index.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../benchmarking/index.html"><strong aria-hidden="true">7.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="../logging-and-tracing/index.html"><strong aria-hidden="true">8.</strong> Logging and Tracing</a></li><li class="chapter-item expanded "><a href="../conditional-compilation/index.html"><strong aria-hidden="true">9.</strong> Conditional Compilation</a></li><li class="chapter-item expanded "><a href="../environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> Environment and Configuration</a></li><li class="chapter-item expanded "><a href="../linq/index.html"><strong aria-hidden="true">11.</strong> LINQ</a></li><li class="chapter-item expanded "><a href="../meta-programming/index.html"><strong aria-hidden="true">12.</strong> Meta Programming</a></li><li class="chapter-item expanded "><a href="../asynchronous-programming/index.html"><strong aria-hidden="true">13.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../project-structure/index.html"><strong aria-hidden="true">14.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="../compilation-and-building/index.html"><strong aria-hidden="true">15.</strong> Compilation and Building</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for C#/.NET Developers</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/microsoft/rust-for-dotnet-devs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/microsoft/rust-for-dotnet-devs/edit/main/src/memory-management/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h1>
<p>Like C# and .NET, Rust has <em>memory-safety</em> to avoid a whole class of bugs
related to memory access, and which end up being the source of many security
vulnerabilities in software. However, Rust can guarantee memory-safety at
compile-time; there is no run-time (like the CLR) making checks. The one
exception here is array bound checks that are done by the compiled code at
run-time, be that the Rust compiler or the JIT compiler in .NET. Like C#, it
is also <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">possible to write unsafe code in Rust</a>, and in fact,
both languages even share the same keyword, <em>literally</em> <code>unsafe</code>, to mark
functions and blocks of code where memory-safety is no longer guaranteed.</p>
<p>Rust has no garbage collector (GC). All memory management is entirely the
responsibility of the developer. That said, <em>safe Rust</em> has rules around
ownership that ensure memory is freed <em>as soon as</em> it's no longer in use (e.g.
when leaving the scope of a block or a function). The compiler does a
tremendous job, through (compile-time) static analysis, of helping manage that
memory through <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">ownership</a> rules. If violated, the compiler rejects the code
with a compilation error.</p>
<p>In .NET, there is no concept of ownership of memory beyond the GC roots
(static fields, local variables on a thread's stack, CPU registers, handles,
etc.). It is the GC that walks from the roots during a collection to detemine
all memory in use by following references and purging the rest. When designing
types and writing code, a .NET developer can remain oblivious to ownership,
memory management and even how the garbage collector works for the most part,
except when performance-sensitive code requires paying attention to the amount
and rate at which objects are being allocated on the heap. In contrast, Rust's
ownership rules require the developer to explicitly think and express
ownership at all times and it impacts everything from the design of functions,
types, data structures to how the code is written. On top of that, Rust has
strict rules about how data is used such that it can identify at compile-time,
data <a href="https://doc.rust-lang.org/nomicon/races.html">race conditions</a> as well as corruption issues (requiring thread-safety)
that could potentially occur at run-time. This section will only focus on
memory management and ownership.</p>
<p>There can only be one owner of some memory, be that on the stack or heap,
backing a structure at any given time in Rust. The compiler assigns
<a href="https://doc.rust-lang.org/rust-by-example/scope/lifetime.html">lifetimes</a> and tracks ownership. It is possible to pass or
yield ownership, which is called <em>moving</em> in Rust. These ideas are briefly
illustrated in the example Rust code below:</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let a = Point { x: 12, y: 34 }; // point owned by a
    let b = a;                      // b owns the point now
    println!(&quot;{}, {}&quot;, a.x, a.y);   // compiler error!
}</code></pre>
<p>The first statement in <code>main</code> will allocate <code>Point</code> and that memory will be
owned by <code>a</code>. In the second statement, the ownership is moved from <code>a</code> to <code>b</code>
and <code>a</code> can no longer be used because it no longer owns anything or represents
valid memory. The last statement that tries to print the fields of the point
via <code>a</code> will fail compilation. Suppose <code>main</code> is fixed to read as follows:</p>
<pre><code class="language-rust">fn main() {
    let a = Point { x: 12, y: 34 }; // point owned by a
    let b = a;                      // b owns the point now
    println!(&quot;{}, {}&quot;, b.x, b.y);   // ok, uses b
}   // point behind b is dropped</code></pre>
<p>Note that when <code>main</code> exits, <code>a</code> and <code>b</code> will go out of scope. The memory
behind <code>b</code> will be released by virtue of the stack returning to its state
prior to <code>main</code> being called. In Rust, one says that the point behind <code>b</code> was
<em>dropped</em>. However, note that since <code>a</code> yielded its ownership of the point to
<code>b</code>, there is nothing to drop when <code>a</code> goes out of scope.</p>
<p>A <code>struct</code> in Rust can define code to execute when an instance is dropped by
implementing the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait.</p>
<p>The rough equivalent of <em>dropping</em> in C# would be a class <a href="https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/finalizers">finalizer</a>, but
while a finalizer is called <em>automatically</em> by the GC at some future point,
dropping in Rust is always instantaneous and deterministic; that is, it
happens at the point the compiler has determined that an instance has no owner
based on scopes and lifetimes. In .NET, the equivalent of <code>Drop</code> would be
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.idisposable"><code>IDisposable</code></a> and is implemented by types to release any
unmanaged resources or memory they hold. <em>Deterministic disposal</em> is not
enforced or guaranteed, but the <code>using</code> statement in C# is typically used to
scope an instance of a disposable type such that it gets disposed
determinstically, at the end of the <code>using</code> statement's block.</p>
<p>Rust has the notion of a global lifetime denoted by <code>'static</code>, which is a
reserved lifetime specifier. A very rough approximation in C# would be static
<em>read-only</em> fields of types.</p>
<p>In C# and .NET, references are shared freely without much thought so the idea
of a single owner and yielding/moving ownership may seem very limiting in
Rust, but it is possible to have <em>shared ownership</em> in Rust using the smart
pointer type <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html"><code>Rc</code></a>; it adds reference-counting. Each time <a href="https://doc.rust-lang.org/stable/std/rc/struct.Rc.html#method.clone">the smart
pointer is cloned</a>, the reference count is incremented. When the
clone drops, the reference count is decremented. The actual instance behind
the smart pointer is dropped when the reference count reaches zero. These
points are illustrated by the following examples that build on the previous:</p>
<pre><code class="language-rust">#![allow(dead_code, unused_variables)]

use std::rc::Rc;

struct Point {
    x: i32,
    y: i32,
}

impl Drop for Point {
    fn drop(&amp;mut self) {
        println!(&quot;Point dropped!&quot;);
    }
}

fn main() {
    let a = Rc::new(Point { x: 12, y: 34 });
    let b = Rc::clone(&amp;a); // share with b
    println!(&quot;a = {}, {}&quot;, a.x, a.y); // okay to use a
    println!(&quot;b = {}, {}&quot;, b.x, b.y);
}

// prints:
// a = 12, 34
// b = 12, 34
// Point dropped!</code></pre>
<p>Note that:</p>
<ul>
<li>
<p><code>Point</code> implements the <code>drop</code> method of the <code>Drop</code> trait and prints a
message when an instance of a <code>Point</code> is dropped.</p>
</li>
<li>
<p>The point created in <code>main</code> is wrapped behind the smart pointer <code>Rc</code> and so
the smart pointer <em>owns</em> the point and not <code>a</code>.</p>
</li>
<li>
<p><code>b</code> gets a clone of the smart pointer that effectively increments the
reference count to 2. Unlike the earlier example, where <code>a</code> transferred its
ownership of point to <code>b</code>, both <code>a</code> and <code>b</code> own their own distinct clones of
the smart pointer, so it is okay to continue to use <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>The compiler will have determined that <code>a</code> and <code>b</code> go out of scope at the
end of <code>main</code> and therefore injected calls to drop each. The <code>Drop</code>
implementation of <code>Rc</code> will decrement the reference count and also drop what
it owns if the reference count has reached zero. When that happens, the
<code>Drop</code> implementation of <code>Point</code> will print the message, “Point
dropped!” The fact that the message is printed once demonstrates that
only one point was created, shared and dropped.</p>
</li>
</ul>
<p><code>Rc</code> is not thread-safe. For shared ownership in a multi-threaded program, the
Rust standard library offers <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> instead. The Rust language will
prevent the use of <code>Rc</code> across threads.</p>
<p>In .NET, value types (like <code>enum</code> and <code>struct</code> in C#) live on the stack and
reference types (<code>interface</code>, <code>record class</code> and <code>class</code> in C#) are
heap-allocated. In Rust, the kind of type (basically <code>enum</code> or <code>struct</code> <em>in
Rust</em>), does not determine where the backing memory will eventually live. By
default, it is always on the stack, but just the way .NET and C# have a notion
of boxing value types, which copies them to the heap, the way to allocate a
type on the heap is to box it using <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>:</p>
<pre><code class="language-rust">let stack_point = Point { x: 12, y: 34 };
let heap_point = Box::new(Point { x: 12, y: 34 });</code></pre>
<p>Like <code>Rc</code> and <code>Arc</code>, <code>Box</code> is a smart pointer, but unlike <code>Rc</code> and <code>Arc</code>, it
exclusively owns the instance behind it. All of these smart pointers allocate
an instance of their type argument <code>T</code> on the heap.</p>
<p>The <code>new</code> keyword in C# creates an instance of a type, and while members such
as <code>Box::new</code> and <code>Rc::new</code> that you see in the examples may seem to have a
similar purpose, <code>new</code> has no special designation in Rust. It's merely a
<em>coventional name</em> that is meant to denote a factory. In fact they are called
<em>associated functions</em> of the type, which is Rust's way of saying static
methods.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language/documentation-comments.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../resource-management/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language/documentation-comments.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../resource-management/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../ferris.js"></script>


    </body>
</html>
