<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Asynchronous Programming - Rust for C#/.NET Developers</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="../license.html">License</a></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../language/index.html"><strong aria-hidden="true">2.</strong> Language</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/scalar-types.html"><strong aria-hidden="true">2.1.</strong> Scalar Types</a></li><li class="chapter-item expanded "><a href="../language/strings.html"><strong aria-hidden="true">2.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="../language/structured-types.html"><strong aria-hidden="true">2.3.</strong> Structured Types</a></li><li class="chapter-item expanded "><a href="../language/custom-types/index.html"><strong aria-hidden="true">2.4.</strong> Custom Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language/custom-types/classes.html"><strong aria-hidden="true">2.4.1.</strong> Classes</a></li><li class="chapter-item expanded "><a href="../language/custom-types/records.html"><strong aria-hidden="true">2.4.2.</strong> Records</a></li><li class="chapter-item expanded "><a href="../language/custom-types/structs.html"><strong aria-hidden="true">2.4.3.</strong> Structures</a></li><li class="chapter-item expanded "><a href="../language/custom-types/interfaces.html"><strong aria-hidden="true">2.4.4.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="../language/custom-types/enums.html"><strong aria-hidden="true">2.4.5.</strong> Enumeration Types</a></li><li class="chapter-item expanded "><a href="../language/custom-types/members.html"><strong aria-hidden="true">2.4.6.</strong> Members</a></li></ol></li><li class="chapter-item expanded "><a href="../language/local-functions.html"><strong aria-hidden="true">2.5.</strong> Local Functions</a></li><li class="chapter-item expanded "><a href="../language/lambda-and-closures.html"><strong aria-hidden="true">2.6.</strong> Lambda and Closures</a></li><li class="chapter-item expanded "><a href="../language/variables.html"><strong aria-hidden="true">2.7.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../language/namespaces.html"><strong aria-hidden="true">2.8.</strong> Namespaces</a></li><li class="chapter-item expanded "><a href="../language/equality.html"><strong aria-hidden="true">2.9.</strong> Equality</a></li><li class="chapter-item expanded "><a href="../language/generics.html"><strong aria-hidden="true">2.10.</strong> Generics</a></li><li class="chapter-item expanded "><a href="../language/polymorphism.html"><strong aria-hidden="true">2.11.</strong> Polymorphism</a></li><li class="chapter-item expanded "><a href="../language/inheritance.html"><strong aria-hidden="true">2.12.</strong> Inheritance</a></li><li class="chapter-item expanded "><a href="../language/exception-handling.html"><strong aria-hidden="true">2.13.</strong> Exception Handling</a></li><li class="chapter-item expanded "><a href="../language/nullability-and-optionality.html"><strong aria-hidden="true">2.14.</strong> Nullability and Optionality</a></li><li class="chapter-item expanded "><a href="../language/discards.html"><strong aria-hidden="true">2.15.</strong> Discards</a></li><li class="chapter-item expanded "><a href="../language/conversion-and-casting.html"><strong aria-hidden="true">2.16.</strong> Conversion and Casting</a></li><li class="chapter-item expanded "><a href="../language/operator-overloading.html"><strong aria-hidden="true">2.17.</strong> Operator Overloading</a></li><li class="chapter-item expanded "><a href="../language/documentation-comments.html"><strong aria-hidden="true">2.18.</strong> Documentation Comments</a></li></ol></li><li class="chapter-item expanded "><a href="../memory-management/index.html"><strong aria-hidden="true">3.</strong> Memory Management</a></li><li class="chapter-item expanded "><a href="../resource-management/index.html"><strong aria-hidden="true">4.</strong> Resource Management</a></li><li class="chapter-item expanded "><a href="../threading/index.html"><strong aria-hidden="true">5.</strong> Threading</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../threading/synchronization.html"><strong aria-hidden="true">5.1.</strong> Synchronization</a></li><li class="chapter-item expanded "><a href="../threading/producer-consumer.html"><strong aria-hidden="true">5.2.</strong> Producer-Consumer</a></li></ol></li><li class="chapter-item expanded "><a href="../testing/index.html"><strong aria-hidden="true">6.</strong> Testing</a></li><li class="chapter-item expanded "><a href="../benchmarking/index.html"><strong aria-hidden="true">7.</strong> Benchmarking</a></li><li class="chapter-item expanded "><a href="../logging-and-tracing/index.html"><strong aria-hidden="true">8.</strong> Logging and Tracing</a></li><li class="chapter-item expanded "><a href="../conditional-compilation/index.html"><strong aria-hidden="true">9.</strong> Conditional Compilation</a></li><li class="chapter-item expanded "><a href="../environment-and-configuration/index.html"><strong aria-hidden="true">10.</strong> Environment and Configuration</a></li><li class="chapter-item expanded "><a href="../linq/index.html"><strong aria-hidden="true">11.</strong> LINQ</a></li><li class="chapter-item expanded "><a href="../meta-programming/index.html"><strong aria-hidden="true">12.</strong> Meta Programming</a></li><li class="chapter-item expanded "><a href="../asynchronous-programming/index.html" class="active"><strong aria-hidden="true">13.</strong> Asynchronous Programming</a></li><li class="chapter-item expanded "><a href="../project-structure/index.html"><strong aria-hidden="true">14.</strong> Project Structure</a></li><li class="chapter-item expanded "><a href="../compilation-and-building/index.html"><strong aria-hidden="true">15.</strong> Compilation and Building</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for C#/.NET Developers</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/microsoft/rust-for-dotnet-devs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/microsoft/rust-for-dotnet-devs/edit/main/src/asynchronous-programming/index.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="asynchronous-programming"><a class="header" href="#asynchronous-programming">Asynchronous Programming</a></h1>
<p>Both .NET and Rust support asynchronous programming models, which look similar
to each other with respect to their usage. The following example shows, on a
very high level, how async code looks like in C#:</p>
<pre><code class="language-csharp">async Task&lt;string&gt; PrintDelayed(string message, CancellationToken cancellationToken)
{
    await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
    return $&quot;Message: {message}&quot;;
}
</code></pre>
<p>Rust code is structured similarly. The following sample relies on <a href="https://docs.rs/async-std/latest/async_std/">async-std</a>
for the implementation of <code>sleep</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::time::Duration;
use async_std::task::sleep;

async fn format_delayed(message: &amp;str) -&gt; String {
    sleep(Duration::from_secs(1)).await;
    format!(&quot;Message: {}&quot;, message)
}
<span class="boring">}</span></code></pre></pre>
<ol>
<li>
<p>The Rust <a href="https://doc.rust-lang.org/std/keyword.async.html"><code>async</code></a> keyword transforms a block of code into a state
machine that implements a trait called <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>, similarly to
how the C# compiler transforms <code>async</code> code into a state machine. In both
languages, this allows for writing asynchronous code sequentially.</p>
</li>
<li>
<p>Note that for both Rust and C#, asynchronous methods/functions are prefixed
with the async keyword, but the return types are different. Asynchronous
methods in C# indicate the full and actual return type because it can vary.
For example, it is common to see some methods return a <code>Task&lt;T&gt;</code> while others
return a <code>ValueTask&lt;T&gt;</code>. In Rust, it is enough to specify the <em>inner type</em>
<code>String</code> because it's <em>always some future</em>; that is, a type that implements
the <code>Future</code> trait.</p>
</li>
<li>
<p>The <code>await</code> keywords are in different positions in C# and Rust. In C#, a
<code>Task</code> is awaited by prefixing the expression with <code>await</code>. In Rust,
suffixing the expression with the <code>.await</code> keyword allows for <em>method
chaining</em>, even though <code>await</code> is not a method.</p>
</li>
</ol>
<p>See also:</p>
<ul>
<li><a href="https://rust-lang.github.io/async-book/">Asynchronous programming in Rust</a></li>
</ul>
<h2 id="executing-tasks"><a class="header" href="#executing-tasks">Executing tasks</a></h2>
<p>From the following example the <code>PrintDelayed</code> method executes, even though it is
not awaited:</p>
<pre><code class="language-csharp">var cancellationToken = CancellationToken.None;
PrintDelayed(&quot;message&quot;, cancellationToken); // Prints &quot;message&quot; after a second.
await Task.Delay(TimeSpan.FromSeconds(2), cancellationToken);

async Task PrintDelayed(string message, CancellationToken cancellationToken)
{
    await Task.Delay(TimeSpan.FromSeconds(1), cancellationToken);
    Console.WriteLine(message);
}
</code></pre>
<p>In Rust, the same function invocation does not print anything.</p>
<pre><pre class="playground"><code class="language-rust">use async_std::task::sleep;
use std::time::Duration;

#[tokio::main] // used to support an asynchronous main method
async fn main() {
    print_delayed(&quot;message&quot;); // Prints nothing.
    sleep(Duration::from_secs(2)).await;
}

async fn print_delayed(message: &amp;str) {
    sleep(Duration::from_secs(1)).await;
    println!(&quot;{}&quot;, message);
}</code></pre></pre>
<p>This is because futures are lazy: they do nothing until they are run. The most
common way to run a <code>Future</code> is to <code>.await</code> it. When <code>.await</code> is called on a
<code>Future</code>, it will attempt to run it to completion. If the <code>Future</code> is blocked,
it will yield control of the current thread. When more progress can be made, the
<code>Future</code> will be picked up by the executor and will resume running, allowing the
<code>.await</code> to resolve (see <a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html#asyncawait"><code>async/.await</code></a>).</p>
<p>While awaiting a function works from within other <code>async</code> functions, <code>main</code> <a href="https://doc.rust-lang.org/error-index.html#E0752">is
not allowed to be <code>async</code></a>. This is a consequence of the fact that
Rust itself does not provide a runtime for executing asynchronous code. Hence,
there are libraries for executing asynchronous code, called <a href="https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html#async-runtimes">async runtimes</a>.
<a href="https://crates.io/crates/tokio">Tokio</a> is such an async runtime, and it is frequently used.
<a href="https://docs.rs/tokio/latest/tokio/attr.main.html"><code>tokio::main</code></a> from the above example marks the <code>async main</code>
function as entry point to be executed by a runtime, which is set up
automatically when using the macro.</p>
<h2 id="task-cancellation"><a class="header" href="#task-cancellation">Task cancellation</a></h2>
<p>The previous C# examples included passing a <code>CancellationToken</code> to asynchronous
methods, as is considered best practice in .NET. <code>CancellationToken</code>s can be
used to abort an asynchronous operation.</p>
<p>Because futures are inert in Rust (they make progress only when polled),
cancellation works differently in Rust. When dropping a <code>Future</code>, the <code>Future</code>
will make no further progress. It will also drop all instantiated values up to
the point where the future is suspended due to some outstanding asynchronous
operation. This is why most asynchronous functions in Rust don't take an
argument to signal cancellation, and is why dropping a future is sometimes being
referred to as <em>cancellation</em>.</p>
<p><a href="https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"><code>tokio_util::sync::CancellationToken</code></a> offers an
equivalent to the .NET <code>CancellationToken</code> to signal and react to cancellation,
for cases where implementing the <code>Drop</code> trait on a <code>Future</code> is unfeasible.</p>
<h2 id="executing-multiple-tasks"><a class="header" href="#executing-multiple-tasks">Executing multiple Tasks</a></h2>
<p>In .NET, <code>Task.WhenAny</code> and <code>Task.WhenAll</code> are frequently used to handle the
execution of multiple tasks.</p>
<p><code>Task.WhenAny</code> completes as soon as any task completes. Tokio, for example,
provides the <a href="https://docs.rs/tokio/latest/tokio/macro.select.html"><code>tokio::select!</code></a> macro as an alternative for
<code>Task.WhenAny</code>, which means to wait on multiple concurrent branches.</p>
<pre><code class="language-csharp">var cancellationToken = CancellationToken.None;

var result =
    await Task.WhenAny(Delay(TimeSpan.FromSeconds(2), cancellationToken),
                       Delay(TimeSpan.FromSeconds(1), cancellationToken));

Console.WriteLine(result.Result); // Waited 1 second(s).

async Task&lt;string&gt; Delay(TimeSpan delay, CancellationToken cancellationToken)
{
    await Task.Delay(delay, cancellationToken);
    return $&quot;Waited {delay.TotalSeconds} second(s).&quot;;
}
</code></pre>
<p>The same example for Rust:</p>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
use tokio::{select, time::sleep};

#[tokio::main]
async fn main() {
    let result = select! {
        result = delay(Duration::from_secs(2)) =&gt; result,
        result = delay(Duration::from_secs(1)) =&gt; result,
    };

    println!(&quot;{}&quot;, result); // Waited 1 second(s).
}

async fn delay(delay: Duration) -&gt; String {
    sleep(delay).await;
    format!(&quot;Waited {} second(s).&quot;, delay.as_secs())
}</code></pre></pre>
<p>Again, there are crucial differences in semantics between the two examples. Most
importantly, <code>tokio::select!</code> will cancel all remaining branches, while
<code>Task.WhenAny</code> leaves it up to the user to cancel any in-flight tasks.</p>
<p>Similarly, <code>Task.WhenAll</code> can be replaced with <a href="https://docs.rs/tokio/latest/tokio/macro.join.html"><code>tokio::join!</code></a>.</p>
<h2 id="multiple-consumers"><a class="header" href="#multiple-consumers">Multiple consumers</a></h2>
<p>In .NET a <code>Task</code> can be used across multiple consumers. All of them can await
the task and get notified when the task is completed or failed. In Rust, the
<code>Future</code> can not be cloned or copied, and <code>await</code>ing will move the ownership.
The <code>futures::FutureExt::shared</code> extension creates a cloneable handle to a
<code>Future</code>, which then can be distributed across multiple consumers.</p>
<pre><pre class="playground"><code class="language-rust">use futures::FutureExt;
use std::time::Duration;
use tokio::{select, time::sleep, signal};
use tokio_util::sync::CancellationToken;

#[tokio::main]
async fn main() {
    let token = CancellationToken::new();
    let child_token = token.child_token();

    let bg_operation = background_operation(child_token);

    let bg_operation_done = bg_operation.shared();
    let bg_operation_final = bg_operation_done.clone();

    select! {
        _ = bg_operation_done =&gt; {},
        _ = signal::ctrl_c() =&gt; {
            token.cancel();
        },
    }

    bg_operation_final.await;
}

async fn background_operation(cancellation_token: CancellationToken) {
    select! {
        _ = sleep(Duration::from_secs(2)) =&gt; println!(&quot;Background operation completed.&quot;),
        _ = cancellation_token.cancelled() =&gt; println!(&quot;Background operation cancelled.&quot;),
    }
}</code></pre></pre>
<h2 id="asynchronous-iteration"><a class="header" href="#asynchronous-iteration">Asynchronous iteration</a></h2>
<p>While in .NET there are <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerable-1"><code>IAsyncEnumerable&lt;T&gt;</code></a> and
<a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.iasyncenumerator-1"><code>IAsyncEnumerator&lt;T&gt;</code></a>, Rust does not yet have an API for
asynchronous iteration in the standard library. To support asynchronous
iteration, the <a href="https://rust-lang.github.io/async-book/05_streams/01_chapter.html"><code>Stream</code></a> trait from <a href="https://docs.rs/futures/latest/futures/stream/trait.Stream.html"><code>futures</code></a>
offers a comparable set of functionality.</p>
<p>In C#, writing async iterators has comparable syntax to when writing synchronous
iterators:</p>
<pre><code class="language-csharp">await foreach (int item in RangeAsync(10, 3).WithCancellation(CancellationToken.None))
    Console.Write(item + &quot; &quot;); // Prints &quot;10 11 12&quot;.

async IAsyncEnumerable&lt;int&gt; RangeAsync(int start, int count)
{
    for (int i = 0; i &lt; count; i++)
    {
        await Task.Delay(TimeSpan.FromSeconds(i));
        yield return start + i;
    }
}
</code></pre>
<p>In Rust, there are several types that implement the <code>Stream</code> trait, and hence
can be used for creating streams, e.g. <code>futures::channel::mpsc</code>. For a syntax
closer to C#, <a href="https://github.com/tokio-rs/async-stream"><code>async-stream</code></a> offers a set of macros that
can be used to generate streams succinctly.</p>
<pre><pre class="playground"><code class="language-rust">use async_stream::stream;
use futures_core::stream::Stream;
use futures_util::{pin_mut, stream::StreamExt};
use std::{
    io::{stdout, Write},
    time::Duration,
};
use tokio::time::sleep;

#[tokio::main]
async fn main() {
    let stream = range(10, 3);
    pin_mut!(stream); // needed for iteration
    while let Some(result) = stream.next().await {
        print!(&quot;{} &quot;, result); // Prints &quot;10 11 12&quot;.
        stdout().flush().unwrap();
    }
}

fn range(start: i32, count: i32) -&gt; impl Stream&lt;Item = i32&gt; {
    stream! {
        for i in 0..count {
            sleep(Duration::from_secs(i as _)).await;
            yield start + i;
        }
    }
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../meta-programming/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../project-structure/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../meta-programming/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../project-structure/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
